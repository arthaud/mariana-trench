"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[435],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>d,mdx:()=>y,useMDXComponents:()=>u,withMDXComponents:()=>p});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},o.apply(this,arguments)}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),p=function(e){return function(t){var n=u(t.components);return r.createElement(e,o({},t,{components:n}))}},u=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=u(e.components);return r.createElement(c.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=i,m=p["".concat(l,".").concat(d)]||p[d]||f[d]||o;return n?r.createElement(m,a(a({ref:t},c),{},{components:n})):r.createElement(m,a({ref:t},c))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,l=new Array(o);l[0]=m;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a.mdxType="string"==typeof e?e:i,l[1]=a;for(var c=2;c<o;c++)l[c]=n[c];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},47441:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const o={id:"exploitability-rules",title:"Exploitability Rules",sidebar_label:"Exploitability Rules"},l=void 0,a={unversionedId:"exploitability-rules",id:"exploitability-rules",title:"Exploitability Rules",description:"Exploitability Rules",source:"@site/documentation/exploitability_rules.md",sourceDirName:".",slug:"/exploitability-rules",permalink:"/docs/exploitability-rules",draft:!1,editUrl:"https://github.com/facebook/mariana-trench/tree/main/documentation/website/documentation/exploitability_rules.md",tags:[],version:"current",frontMatter:{id:"exploitability-rules",title:"Exploitability Rules",sidebar_label:"Exploitability Rules"}},s={},c=[{value:"Exploitability Rules",id:"exploitability-rules",level:3}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.mdx)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.mdx)("h3",{id:"exploitability-rules"},"Exploitability Rules"),(0,i.mdx)("p",null,"For android, some source to sink flows are only considered valid if the root callable of the source to sink flow is also accessible from outside the app.\nThis access is controlled by exported setting in the manifest file.\nExploitability rules allow us to additionally constraint source to sink rules on a call-chain flow from the root callable of the source to sink flow up to a call-chain effect source which is identified using the android manifest.\nEg."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-java"},"class ExportedActivity extends Activity {\n    void onCreate() {\n        Util.rootCallable(this);\n    }\n}\n\nclass Util {\n    void rootCallable(Activity activity) {\n        toSink(activity.getSource());\n    }\n}\n")),(0,i.mdx)("p",null,"Here, if we want to report an issue only if the android manifest sets ",(0,i.mdx)("inlineCode",{parentName:"p"},"exported: true")," for ",(0,i.mdx)("inlineCode",{parentName:"p"},"ExportedActivity"),". You can specify the explotability rule as follows:"),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "Source to sink flow is reachable from an exported class",\n  "code": 1,\n  "description": "Values from source may eventually flow into sink",\n  "sources": [\n    "ActivityUserInput"\n  ],\n  "effect_sources": [\n    "Exported"\n  ],\n  "sinks": [\n    "LaunchingComponent"\n  ]\n}\n')),(0,i.mdx)("p",null,"Here, source to sink flow is found in ",(0,i.mdx)("inlineCode",{parentName:"p"},"rootCallable()")," but the issue will be reported iff ",(0,i.mdx)("inlineCode",{parentName:"p"},"ExportedActivity")," has ",(0,i.mdx)("inlineCode",{parentName:"p"},"exported:true")," in the android manifest."),(0,i.mdx)("pre",null,(0,i.mdx)("code",{parentName:"pre"},"                   ExportedActivity::onCreate(): with effect_source: Exported\n                           |\n                   rootCallable(): with inferred effect_sink: ActivityUserInput@LaunchingComponent\n                           |\n         +-----------------+-----------------+\n         |                                   |\n  getSource(): with                      toSink(): with\nsource kind: ActivityUserInput        sink kind: LaunchingComponent\n")))}u.isMDXComponent=!0}}]);